using Azure;
using Azure.AI.OpenAI;
using Microsoft.Extensions.Configuration;
using Polly;
using Polly.Retry;

namespace custom_indexing_api.Utils
{

    // class to hold prompts in key value pairs
    public static class FEWSHOT_CONFIG
    {
        public const string CODE_DESC_ASSISTANT_PROMPT =
            $"{{\"code_summary\":\"{CODE_SUMMARY}\",\"code_description\": \"{CODE_DESCRIPTION}\"}}";

        public const string CODE_DESC_ASSISTANT_USER =
        $"{FILE_EXAMPLE}";

        private const string FILE_EXAMPLE =
            @"
                using NLog;\r\nusing NLog.Config;\r\nusing NLog.Targets;\r\nusing System.ComponentModel.Composition;\r\nusing System.ComponentModel.Composition.Hosting;\r\nusing System.Globalization;\r\nusing System.IO;\r\nusing System.Waf.Applications;\r\nusing System.Waf.Applications.Services;\r\nusing System.Waf.Presentation;\r\nusing System.Windows;\r\nusing System.Windows.Markup;\r\nusing System.Windows.Threading;\r\nusing Waf.MusicManager.Applications.Services;\r\nusing Waf.MusicManager.Applications.ViewModels;\r\nusing Waf.MusicManager.Presentation.Services;\r\n\r\nnamespace Waf.MusicManager.Presentation;\r\n\r\npublic partial class App\r\n{\r\n    private static readonly Tuple<string, LogLevel>[] logSettings =\r\n    {\r\n        Tuple.Create(\""App\"", LogLevel.Info),\r\n        Tuple.Create(\""MusicManager.*\"", LogLevel.Warn),\r\n    };\r\n\r\n    private AggregateCatalog? catalog;\r\n    private CompositionContainer? container;\r\n    private IEnumerable<IModuleController> moduleControllers = Array.Empty<IModuleController>();\r\n\r\n    public App()\r\n    {\r\n        var fileTarget = new FileTarget(\""fileTarget\"")\r\n        {\r\n            FileName = Path.Combine(EnvironmentService.LogPath, \""App.log\""),\r\n            Layout = \""${date:format=yyyy-MM-dd HH\\\\:mm\\\\:ss.ff} ${level} ${processid} ${logger} ${message}  ${exception:format=tostring}\"",\r\n            ArchiveAboveSize = 1024 * 1024 * 5,  // 5 MB\r\n            MaxArchiveFiles = 2,\r\n        };\r\n        var logConfig = new LoggingConfiguration { DefaultCultureInfo = CultureInfo.InvariantCulture };\r\n        logConfig.AddTarget(fileTarget);\r\n        var maxLevel = LogLevel.AllLoggingLevels.Last();\r\n        foreach (var x in logSettings) logConfig.AddRule(x.Item2, maxLevel, fileTarget, x.Item1);\r\n        LogManager.Configuration = logConfig;\r\n    }\r\n\r\n    protected override void OnStartup(StartupEventArgs e)\r\n    {\r\n        base.OnStartup(e);\r\n        Log.App.Info(\""{0} {1} is starting; OS: {2}\"", ApplicationInfo.ProductName, ApplicationInfo.Version, Environment.OSVersion);\r\n\r\n#if !DEBUG\r\n        DispatcherUnhandledException += AppDispatcherUnhandledException;\r\n        AppDomain.CurrentDomain.UnhandledException += AppDomainUnhandledException;\r\n#endif\r\n        catalog = new AggregateCatalog();\r\n        catalog.Catalogs.Add(new AssemblyCatalog(typeof(IMessageService).Assembly));\r\n        catalog.Catalogs.Add(new AssemblyCatalog(typeof(ShellViewModel).Assembly));\r\n        catalog.Catalogs.Add(new AssemblyCatalog(typeof(App).Assembly));\r\n        container = new CompositionContainer(catalog, CompositionOptions.DisableSilentRejection);\r\n        var batch = new CompositionBatch();\r\n        batch.AddExportedValue(container);\r\n        container.Compose(batch);\r\n\r\n        FrameworkElement.LanguageProperty.OverrideMetadata(typeof(FrameworkElement), new FrameworkPropertyMetadata(XmlLanguage.GetLanguage(CultureInfo.CurrentCulture.IetfLanguageTag)));\r\n\r\n        moduleControllers = container.GetExportedValues<IModuleController>();\r\n        foreach (var x in moduleControllers) x.Initialize();\r\n        foreach (var x in moduleControllers) x.Run();\r\n    }\r\n\r\n    protected override void OnExit(ExitEventArgs e)\r\n    {\r\n        foreach (var x in moduleControllers.Reverse()) x.Shutdown();\r\n        if (container is not null)\r\n        {\r\n            var shellService = container.GetExportedValue<IShellService>();\r\n            var tasksToWait = shellService.TasksToCompleteBeforeShutdown.ToArray();\r\n            while (tasksToWait.Any(t => !t.IsCompleted))  // Wait until all registered tasks are finished\r\n            {\r\n                DispatcherHelper.DoEvents();\r\n                Thread.Sleep(25);\r\n            }\r\n        }\r\n        container?.Dispose();\r\n        catalog?.Dispose();\r\n        base.OnExit(e);\r\n    }\r\n\r\n    private static void AppDispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e) => HandleException(e.Exception, false);\r\n\r\n    private static void AppDomainUnhandledException(object sender, UnhandledExceptionEventArgs e) => HandleException(e.ExceptionObject as Exception, e.IsTerminating);\r\n\r\n    private static void HandleException(Exception? e, bool isTerminating)\r\n    {\r\n        if (e == null) return;\r\n        Log.App.Error(e, \""Unknown application error.\"");\r\n        if (!isTerminating)\r\n        {\r\n            MessageBox.Show(string.Format(CultureInfo.CurrentCulture, Presentation.Properties.Resources.UnknownError, e), ApplicationInfo.ProductName, MessageBoxButton.OK, MessageBoxImage.Error);\r\n        }\r\n    }\r\n}\r\n\n";

        private const string CODE_DESCRIPTION =
            "# Code Description for App.xaml.cs in Waf.MusicManager Application\n\n## Overview\n\nThis file contains the application's entry point class, `App`, which is derived from `System.Windows.Application`. The `App` class manages the application startup, initialization of modules, and application exit. It also configures the logging mechanism and handles unhandled exceptions.\n\n## Logging Configuration\n\n- **Logging Setup** (`Constructor`):\n  The application configures NLog to log messages to a file named 'App.log' in the specified log path. This setup includes formatting log messages, setting the archive size to 5 MB, and maintaining a maximum of two archive files. The log levels and categories are defined in the `logSettings` array.\n\n## Application Composition\n\n- **MEF Container Creation** (`OnStartup`):\n  An `AggregateCatalog` and `CompositionContainer` are created for managing composition parts, and the application adds several `AssemblyCatalog` items to the catalog (e.g., for `IMessageService`, `ShellViewModel`).\n\n- **Metadata Overriding and Culture Settings** (`OnStartup`):\n  The language of the `FrameworkElement` is set based on the current culture.\n\n- **Module Controllers Initialization and Run** (`OnStartup`):\n  Module controllers are retrieved from the MEF container and initialized. Then, each controller's `Run` method is called.\n\n## Application Exit Handling\n\n- **Module Controllers Shutdown and Task Completion** (`OnExit`):\n  Before exiting, the application shuts down the module controllers in reverse order. It waits for all registered tasks to complete before disposing of the MEF container and catalog.\n\n## Exception Handling\n\n- **Unhandled Exception Handling** (`OnStartup`, `AppDispatcherUnhandledException`, `AppDomainUnhandledException`):\n  The application subscribes to unhandled exception events. In release mode, it handles exceptions thrown by the dispatcher and the AppDomain. If an exception occurs, it is logged as an error, and a message box is displayed to the user (unless the application is terminating).\n\n## External Business Rules and Flows\n\n- **Logging Configuration Rules**:\n  The application's logging behavior is defined by the `logSettings` array, which specifies the log level and logger name pattern.\n\n- **Managed Extensibility Framework (MEF) Rules**:\n  MEF is used for composing the application's parts and managing dependencies. The use of `AggregateCatalog`, `CompositionContainer`, and `CompositionBatch` are key components of this extensibility framework.\n\n- **Application Lifecycle Management**:\n  The application's lifecycle is controlled through the initialization and shutdown of module controllers, as well as task synchronization on exit.\n\n- **Exception Handling Flow**:\n  Exceptions are logged, and users are notified of unhandled exceptions via a message box, contributing to the application's robustness and user experience.\n\n";

        private const string CODE_SUMMARY =
            @"
                The code is part of the Waf.MusicManager application, and it manages the application lifecycle including startup and exit events, setting up logging, handling unhandled exceptions, and managing module controllers. Logging is configured to write to a file with specific settings based on log level and category. The application uses the Managed Extensibility Framework (MEF) for composing parts of the application. On startup, it initializes and runs module controllers, and on exit, it shuts down module controllers and waits for any pending tasks to complete before disposing of the MEF container and catalog.
            ";
        
        private const string MERMAID = 
        @"
            graph LR\n    A[\""Configuration de NLog\""] -->|Log| B[\""Application\""]\n    B --> C[\""Initialisation de MEF\""]\n    C -->|Composition| D[\""Démarrage des modules\""]\n    B --> E[\""Gestion des exceptions non gérées\""]\n    B --> F[\""Arrêt de l'application et nettoyage\""]
        ";
    }
}